# Time to commit - creating productive developers

The amount of software is growing. This leads to the number of developers growing. This in turn causes the number of projects that produces software to grow. Hence the rate of new software is accelerating.

Something needs to be done. The solution for it is still hazy. The future solution might be some low-code platform or copilot like AI or letting software work consume every human resource available. But in the meantime, we need to address this real-life problem in the present.

One of the solutions is training new developers to feed into this amorphous blob of a machine we call software development. This comes at a cost though. New developers need to be onboarded into software projects and ain't nobody got time for that.

With a bit of thinking and planning, onboarding can be tuned to produce productive developers more efficiently and with a lesser impact on the overall team efficiency.

With that being said, If you have a hazy image of what onboarding is, its purposes, and its methods - carry on reading.

## Preface

Since most of my experience is with project work - all text from here on forwards will be in the context of project work.

## What is onboarding?

Onboarding (or organizational socialization) is the process of easing new developers into daily work. The process aims to adjust the new member in several aspects. 

### Role clarity

> Life to me is defined by uncertainty. Uncertainty is the state in which we live, and there is no way to outfox it.
> 
> \- Thomas H. Cook

Role clarity describes a person's understanding of job responsibilities and roles in a given organization. Uncertainty about responsibilities and roles affects productivity negatively. It is hard to start working if the target is blurry.

A Poor onboarding process overlooks responsibilities and roles creating developers with a misguided sense of duty. Even previous experience might not help the new developer since most projects do things in different ways. Therefore the full picture of responsibilities a new developer has is left to be learned from mistakes. Usually accumulating more costs when those mistakes have to be corrected.

Proper role clarity gives the developer a sense of their work. This enhances productivity since it reduces the number of uncertainties. Usually, a small amount of uncertainty means fewer mistakes and therefore fewer costs when fixing broken things.

The most effective way to reduce blurriness when it comes to role clarity is open and transparent communication. Discuss openly what you demand from the new developer and present your project's roles as clearly as possible. If your project has a hard time presenting clear roles to new developers, then consider this as a call to action for having a chat amongst yourselves.

Overall good role clarity is linked to job satisfaction and commitment. A perk that should interest the organization itself when combined with increased productivity on the whole team.

### Self-efficacy

> I used to be scared of uncertainty; now I get a high out of it.
>
> \- Jensen Ackles

Self-efficacy describes an individual's belief in their capacities. A person with high self-efficacy does not shy away from challenges but decides to master them instead. 

When met with a new challenge, a person with high self-efficacy can figure out what skills are needed for the task and, emboldened by the challenge, improve upon them to master the challenge itself. In contrast, a person with low self-efficacy sees the skills they lack and shies away from improving them, losing faith in their skills in the process.

I think it is fair to say that most of us have felt the occasional feeling of being overwhelmed. Either when workload or difficulty overflows the internal firewall of our sense of our abilities. A good onboarding process should take this into account and try to reduce the feeling of being overwhelmed.

Developers who feel they can get given tasks done fare a lot better. This also heavily impacts new developers for they do not necessarily understand the unwritten rules of a given project and what happens if they don't always live up to the standards of the project.

Again the proper way of addressing self-efficacy is open and transparent communication. Be completely open and honest about your expectations for the new developer and also go through the consequences of failing to meet expectations. 

To garner a good sense of self-efficacy during onboarding, new developers should be given tasks from their existing pool of tools and skills. Small achievements affect the courage of taking on harder challenges. An Organizational culture that emphasizes teamwork and employee autonomy also improves self-efficacy.

High self-efficacy in a developer is a positive thing for the employing organization. It has a strong effect on feelings of job satisfaction and commitment. This in turn reduces the employee turnover rate.

### Organizational culture views

> No written law has ever been more binding than unwritten custom supported by popular opinion.
>
> \- Carrie Chapman Catt

Organizational culture views are the mental image of an organization. For new developers, this is a combination of the employing organization itself and the internal culture of a project team.

This contains all things that one considers an organizational culture to be - values, goals, roles, norms, and organizational environment. This also contains a lot of social contracts that encapsulate plenty of unwritten and unspoken rules f.ex. how interactions between hierarchies should be conducted and the views on overtime.

A New developer brings always something new to the table. And when it comes to the zeitgeist of organizational culture there is a chance for growth. Bring a new developer into the project as an equal and value their views on your project's unwritten rules. After all, you want to have an equal developer among you shortly.

The effects that understanding organizational culture has is mostly the same as with self-efficacy. But with culture, the road goes two ways when the new developer and the organization do not share the same values, it might be an uphill battle to make adjustments and the whole process might just end up in failure. An Important facet to consider when recruiting.

### Social acceptance

> Social acceptance, 'being liked,' has so much power because it holds the feelings of loneliness at bay.
>
> \- Rollo May

Social acceptance is the feeling of belonging. It gives new developers the support for success. Unlike role clarity and self-efficacy which described the ability to meet requirements, social acceptance describes the ability to co-exist within an organization. Feelings of not being accepted might have a negative consequence on a new developer. Especially if they come from a group of marginalized identities.

Social acceptance is something that puts requirements on the organizational culture itself. Diversity and inclusion are things that should be ingrained into organizational cultures. This way everyone should be on the same page regarding accepting others.

Social acceptance overlaps with caring. This has a reciprocating effect on productivity. People who go above and beyond in their duties when helping others usually get that help back on the same level hence creating a positive feedback loop.

During onboarding, there should be time dedicated to getting to know each other. It is a lot easier to care for people you know. Not to mention that this eases the daily communication within the team. Idle chat is a perfect way to learn day-to-day communication with different team members and should be somewhat encouraged.

Make your team a safe space. This does not mean walking on eggshells around used language, but communicating openly and when needed apologizing when the situation arises. After all, you can't learn to communicate without actually communicating.

As you can endure a lot more hardships when among social equals, the positive effects of social acceptance are company commitment and therefore reduced employee turnover rate.

## How to onboard

The actual onboarding itself is a tricky subject as everyone responds differently to different stimuli. However, keep in mind that you are helping the new developer develop their views on all aforementioned aspects. You should not spoonfeed any kind of way of thinking but rather support and guide them into forming their own views. This should be easier to do if your project is not in a state of disarray since trying to teach the ins and outs of a chaotic system is futile as you might never be able to form a clear picture of it.

### Have an onboarding plan

We as people react to different stimuli with different responses, hence having only a single plan or track of actions is counterproductive. There are multiple possible tactics for customizing onboarding, but I will focus on three of them.

#### Organic onboarding

This is the low-effort model of onboarding. Throw the new developer into the deep end and see if they can swim. Sounds a lot more radical than it actually is and works very well on certain individuals.

The idea here is to let the new developer figure things out for themselves with the support of the team. This does not mean that the responsibility falls on the new developer, but rather the responsibility is shared across the team.

From my experience, this method is best used with proactive and self-guided people since it demands more from the new developer. Without these traits, this method is prone to failure and will most likely just increase the new developer's confusion.

#### Formal onboarding

This form consists of formal sessions where the new developer is onboarded piecemeal one subject at a time to the project. Usually having some sessions about topics such as domain, tech stack, or the used quality process.

This is, as the name implies, a more formal approach that does not usually take into account the new developer's traits that much and usually forgets the individualization of the onboarding process completely. However, this method is more of a stable process that can be replicated for every future developer also.

For the project, this requires some planning on what topics are required for different individuals and time to prepare the sessions. But the initial cost is the biggest since we developers want to create reusable things. Therefore, a session once held can be replicated in the future bringing the costs down.

From my experience, this method is best used with newer developers that are still searching for a professional self. Developers who have less experience in spotting the more important details that affect their work. The risk in this method is the tendency to spoon-feed information to the new developer without confirming information retention. You can easily overwhelm the new developer to a point where they cannot form clarifying questions thus increasing uncertainty.

This is especially dangerous with new to the field developers since unclear things tend to cumulate and after some point, it is socially awkward to even present those clarifying questions.

#### Mentoring

Mentoring is when an inexperienced person is given a more experienced person as a guide and support. The responsibilities of onboarding in this form are shifted from the team itself to this dynamic pairing.

This method decreases the effort that the whole team must bear, but it also increases the responsibility of the mentoring developer. It is up to the mentor to decide how to tackle the onboarding, so this requires some experience and understanding of onboarding from the mentor. 

With mentoring the intensity might differ from person to person depending on the individual traits of the mentee. Work experience, technical abilities, and personality traits all affect how intense the actual mentoring should be.

### Developer Experience

Onboarding is more soft-skill rather than technical know-how. However, this side of the coin cannot be sidelined completely. After all, there is immense difficulty in teaching someone to embrace chaos.

Developer experience (DX) is something that is not spoken about enough. Developers usually use the created software intensely but usually in a different way from the end user. Designing the experience developers have when interacting with the software being developed in a branch of User Experience (UX) design.

Without going deeper into DX, you should think about how your project DX is designed. Usually, DX grows organically without much designing, but in plenty of projects, it would still be worthwhile to put actual design work into it.

What makes this possible is that since DX is a branch of UX, we can use UX principles in the actual design. For instance, we could take the famous 7 pillars of user experience and fit them into the developer's viewpoint. Things like usability, findability, and credibility are useful pillars when designing DX since they should affect the architecture, tooling, and processes themselves.

DX is such a wide-ranging topic, that it would require another blog post to do it justice. But must be mentioned here, since a good DX affects the onboarding process and the team's efficiency. Happy developers are productive developers regardless of individual experience levels.
